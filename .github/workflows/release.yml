name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g., v1.2.3)"
        required: true

permissions:
  contents: write

jobs:
  build-release:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # For manual runs, build the requested tag; for tag push events, use the event ref.
          ref: ${{ github.event.inputs.tag && format('refs/tags/{0}', github.event.inputs.tag) || github.ref }}

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.20.x"

      - name: Build pingtunnel from source
        shell: pwsh
        run: |
          $version = "2.8"
          $repoUrl = "https://github.com/esrrhs/pingtunnel.git"
          $outputDir = Join-Path $pwd "third_party\\pingtunnel"
          if (-not (Test-Path $outputDir)) { New-Item -ItemType Directory -Path $outputDir | Out-Null }
          $exePath = Join-Path $outputDir "pingtunnel.exe"
          if (Test-Path $exePath) { Remove-Item $exePath -Force }

          $repoDir = Join-Path $env:RUNNER_TEMP "pingtunnel-src"
          if (Test-Path $repoDir) { Remove-Item $repoDir -Recurse -Force }

          $cloned = $false
          foreach ($branch in @("v$version", $version)) {
            try {
              git clone --depth 1 --branch $branch $repoUrl $repoDir
              $cloned = $true
              break
            }
            catch {
              if (Test-Path $repoDir) { Remove-Item $repoDir -Recurse -Force }
            }
          }

          if (-not $cloned) {
            git clone --depth 1 $repoUrl $repoDir
          }

          Push-Location $repoDir
          try {
            go version
            go build -o $exePath
          }
          finally {
            Pop-Location
          }

          if (-not (Test-Path $exePath)) { throw "pingtunnel.exe build failed" }

      - name: Install Inno Setup
        run: choco install innosetup -y

      - name: Resolve version
        id: version
        shell: pwsh
        run: |
          $tag = "${{ github.event.inputs.tag }}"
          if ([string]::IsNullOrWhiteSpace($tag)) {
            $tag = "${{ github.ref_name }}"
          }
          if ($tag.StartsWith("v")) { $version = $tag.Substring(1) } else { $version = $tag }
          $appName = $null
          $configPath = "build.config.ps1"
          if (Test-Path $configPath) {
            $configContent = Get-Content $configPath -Raw
            if ($configContent -match '\$AppName\s*=\s*"([^"]+)"') { $appName = $matches[1] }
          }
          if ([string]::IsNullOrWhiteSpace($appName)) { $appName = "PingTunnelVPN" }
          "RELEASE_TAG=$tag" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "APP_VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "APP_NAME=$appName" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "APP_EXE_NAME=$appName.exe" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "Release tag: $tag"
          Write-Host "App version: $version"
          Write-Host "App name: $appName"

      - name: Update build version
        shell: pwsh
        run: |
          $path = "build.config.ps1"
          if (Test-Path $path) {
            $content = Get-Content $path -Raw
            # Use ${1}/${2} to avoid $11 ambiguity in regex replacement
            $content = $content -replace '(\$AppVersion\s*=\s*")[^"]*(")', "`${1}$env:APP_VERSION`${2}"
            Set-Content -Path $path -Value $content -NoNewline
          }

      - name: Build self-contained release
        shell: pwsh
        run: |
          .\scripts\build.ps1 -Release

      - name: Publish framework-dependent build
        shell: pwsh
        run: |
          $frameworkDir = Join-Path $pwd "dist-framework"
          if (Test-Path $frameworkDir) { Remove-Item $frameworkDir -Recurse -Force }
          $publishDir = Join-Path $frameworkDir "publish"
          dotnet publish "src\PingTunnelVPN.App\PingTunnelVPN.App.csproj" `
            -c Release `
            -r win-x64 `
            --self-contained false `
            -p:PublishSingleFile=false `
            -p:SelfContained=false `
            -o $publishDir

      - name: Publish installer build (self-contained, multi-file)
        shell: pwsh
        run: |
          $installerDir = Join-Path $pwd "dist-installer"
          if (Test-Path $installerDir) { Remove-Item $installerDir -Recurse -Force }
          $publishDir = Join-Path $installerDir "publish"
          dotnet publish "src\PingTunnelVPN.App\PingTunnelVPN.App.csproj" `
            -c Release `
            -r win-x64 `
            --self-contained true `
            -p:PublishSingleFile=false `
            -o $publishDir

      - name: Package artifacts
        shell: pwsh
        run: |
          $root = $pwd
          $artifacts = Join-Path $root "artifacts"
          if (Test-Path $artifacts) { Remove-Item $artifacts -Recurse -Force }
          New-Item -ItemType Directory -Path $artifacts | Out-Null

          # Self-contained output (from dist)
          $dist = Join-Path $root "dist"
          $appExeName = $env:APP_EXE_NAME
          if ([string]::IsNullOrWhiteSpace($appExeName)) { $appExeName = "PingTunnelVPN.exe" }
          $selfExePath = Join-Path $dist $appExeName
          if (-not (Test-Path $selfExePath)) {
            $selfExe = Get-ChildItem -Path $dist -Filter "*.exe" -File |
              Where-Object { $_.Name -notin @("pingtunnel.exe", "tun2socks.exe", "createdump.exe") } |
              Select-Object -First 1
            if (-not $selfExe) { throw "Self-contained exe not found in dist" }
            $selfExePath = $selfExe.FullName
          }

          # Framework-dependent output
          $fwPublish = Join-Path $root "dist-framework\\publish"
          $fwExePath = Join-Path $fwPublish $appExeName
          if (-not (Test-Path $fwExePath)) {
            $fwExe = Get-ChildItem -Path $fwPublish -Filter "*.exe" -File |
              Where-Object { $_.Name -notin @("pingtunnel.exe", "tun2socks.exe", "createdump.exe") } |
              Select-Object -First 1
            if (-not $fwExe) { throw "Framework-dependent exe not found in dist-framework publish" }
            $fwExePath = $fwExe.FullName
          }
          $fwResources = Join-Path $fwPublish "Resources"
          if (-not (Test-Path $fwResources)) {
            $distResources = Join-Path $dist "Resources"
            if (Test-Path $distResources) {
              Copy-Item -Path $distResources -Destination $fwResources -Recurse -Force
            }
          }

          # Portable self-contained (full dist output)
          $portableSelf = Join-Path $artifacts "portable-selfcontained"
          New-Item -ItemType Directory -Path $portableSelf | Out-Null
          Get-ChildItem -Path $dist | Where-Object { $_.Name -ne "publish" } |
            Copy-Item -Destination $portableSelf -Recurse -Force

          # Portable framework-dependent (full publish output)
          $portableFw = Join-Path $artifacts "portable-framework"
          New-Item -ItemType Directory -Path $portableFw | Out-Null
          Copy-Item -Path (Join-Path $fwPublish "*") -Destination $portableFw -Recurse -Force

          # Installer staging (self-contained multi-file publish output)
          $installerFiles = Join-Path $artifacts "installer-files"
          New-Item -ItemType Directory -Path $installerFiles | Out-Null
          $installerPublish = Join-Path $root "dist-installer\\publish"
          if (-not (Test-Path $installerPublish)) { throw "Installer publish output not found" }
          $installerResources = Join-Path $installerPublish "Resources"
          if (-not (Test-Path $installerResources)) {
            $distResources = Join-Path $dist "Resources"
            if (Test-Path $distResources) {
              Copy-Item -Path $distResources -Destination $installerResources -Recurse -Force
            }
          }
          Copy-Item -Path (Join-Path $installerPublish "*") -Destination $installerFiles -Recurse -Force

          # Zip portable outputs
          $selfZip = Join-Path $artifacts ("PingTunnelVPN-selfcontained-" + $env:APP_VERSION + ".zip")
          $fwZip = Join-Path $artifacts ("PingTunnelVPN-framework-" + $env:APP_VERSION + ".zip")
          Compress-Archive -Path (Join-Path $portableSelf "*") -DestinationPath $selfZip
          Compress-Archive -Path (Join-Path $portableFw "*") -DestinationPath $fwZip

      - name: Build installer
        shell: pwsh
        run: |
          $iscc = (Get-Command ISCC.exe -ErrorAction SilentlyContinue)?.Source
          if (-not $iscc) { $iscc = "${env:ProgramFiles(x86)}\\Inno Setup 6\\ISCC.exe" }
          if (-not (Test-Path $iscc)) { throw "ISCC.exe not found" }

          $installerFiles = Resolve-Path "artifacts\\installer-files"
          $appExeName = $env:APP_EXE_NAME
          if ([string]::IsNullOrWhiteSpace($appExeName)) { $appExeName = "PingTunnelVPN.exe" }
          $appExePath = Join-Path $installerFiles $appExeName
          if (-not (Test-Path $appExePath)) {
            $selfExe = Get-ChildItem -Path $installerFiles -Filter "*.exe" -File |
              Where-Object { $_.Name -notin @("pingtunnel.exe", "tun2socks.exe", "createdump.exe") } |
              Select-Object -First 1
            if (-not $selfExe) { throw "Installer exe not found in installer-files" }
            $appExeName = $selfExe.Name
          }

          & $iscc `
            "/DAppVersion=$env:APP_VERSION" `
            "/DAppExeName=$appExeName" `
            "/DSourceDir=$installerFiles" `
            "installer\\PingTunnelVPN.iss"

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          files: |
            artifacts/PingTunnelVPN-Setup-${{ env.APP_VERSION }}.exe
            artifacts/PingTunnelVPN-framework-${{ env.APP_VERSION }}.zip
            artifacts/PingTunnelVPN-selfcontained-${{ env.APP_VERSION }}.zip
